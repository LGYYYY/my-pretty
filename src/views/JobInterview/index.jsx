import React from 'react'
import s from "./index.module.scss";

const JobInterview = () => {
  return (
    <div>
        <h1>面试题</h1>
        <h2>HTTP相关内容</h2>
        <h3>地址栏输入 URL 到页面展现都经历了哪些过程？</h3>
        <p> 1:浏览器解析url地址;<br />
            2:浏览器查看本地有没有缓存，并对比缓存是否过期；<br />
            3.DNS解析url的到当前ip;<br/>
            4:建立TCP链接，进行三次握手；<br />
            5:发起HTTP请求；<br />
            6.服务器进行响应，返回给浏览器数据<br/>
            7:浏览器收到HTTP响应，解析并渲染页面<br/>
            8.关闭TCP链接</p>
        <hr />
        <h3>HTTP和HTTPS的基本概念</h3>
        <p>HTTP（超文本传输协议）:是一个服务端和客户端请求的应答标准（TCP），用于从WWW服务端传输超文本到本地浏览器的超文本传输协议。</p>
        <p>HTTPS:是以安全为目标的HTTP通道，在HTTP的基础上加上SSL层进行加密。作用是：建立一个安全通道，确保数据的传输，以及网站的真实性。</p>
        <h3>HTTP和HTTPS的区别及优缺点</h3>
        <p>1:HTTP是明文传输，HTTPS比起HTTP更安全，有SSL加密，防止信息在传输中被窃取。<br />
           2:HTTP缓存更高效，HTTPS会增加数据开销。<br />
           3:HTTP默认端口号为80，HTTPS默认端口号为443。<br />
           4:HTTP链接简单，是无状态的；HTTPS握手阶段比较费事，页面加载时间更长。<br />
           5:HTTPS需要ca证书。<br />
           6:SSL证书需要绑定IP，一个IP不能绑定多个。</p>
        <h3>HTTPS工作原理流程</h3>
        <p>1:浏览器输入HTTPS URL请求，要求服务器端建立SSL链接。<br />
           2:服务器端收到请求，传输证书给客户端，证书包含公钥等。<br />
           3:客户端和服务器端协商SSL安全等级。<br />
           4:通过协商好的安全等级，建立会话密钥，通过网站的公钥加密会话密钥，传输给网站。<br />
           5:服务器通过自己的私钥解密出会话密钥。<br />
           6:服务器通过会话密钥和客户端之间进行通信。<br />
        </p>
        <h3>TCP三次握手</h3>
        <p>第一次握手：客户端发送SYN包给服务器端，客户端进入SYN_SENT状态。<span className={s.red}>SYN（同步序列编号）</span><br />
           第二次握手：服务器端确认收到客户端发送的SYN包，并且发送自己的SYN包给客户端，进入SYN_RECV状态。
           第三次握手：客户端确认收到服务器端发送的SYN包，像服务器发送确认包，确认客户端已收到。然后建立连接开始传输数据。</p>
        <h3>TCP四次挥手</h3>
        <p>1:客户端发送释放报文给服务器端，并进入FIN-WHITE-1,终止等待1状态。<br />
           2:服务器端收到客户端发送的释放报文请求，并给客户端发送确认报文，此时服务端进入CLOSE_WHITE（关闭等待）状态，TCP通知高层的应用进程，客户端向服务器端的方向就已经释放了，但是服务器端着时候向客户端发送数据，客户端还需要接收数据。<br />
           3:客户端收到服务器端的确认报文后，就进入FIN-WHITE—2,终止等待2状态。等待服务器端发送链接释放报文。<br />
           4:服务器端将最后的数据发送之后，就发送释放确认报文，服务器进入LASK-ASK（最后确认）状态。<br />
           5:客户端收到服务器端的释放报文后需要发送确认。<br />
           6:服务器端收到客户端端确认之后进入CLOSED状态。<br />
           <span className={s.red}>(ACK:确认字符)</span>
           </p>
         <h3>TCP/IP如何保证数据包传输的有序可靠？</h3>
         <p>对字节流进行分段进行编号让后通过ACK回复和超时重发这两个机制进行数据包的有序传输。</p>
         <p>1.为了保证数据包的有序传输，发送发必须吧数据包保留在缓冲区。<br />
            2.并且为每一个数据包设置一个定时器。<br />
            3.如果在定时器超时之前收到接受方发来的消息，就可以释放该数据包占用的缓冲区。<br />
            4.如果超时未收到接受方的确认消息，则重新发送该数据包，直至发送成功或者超过最大重发次数。<br />
            5.接受方接受到数据包之后，会先进行CRC校验，正确的话就发送给上层协议，然后给对方发一个累积应答包，表明接收到数据，如果接受方也有数据要发送给应答方，也可以通过应答包携带过去。<br />
            <span className={s.red}>(CRC：循环冗余校核)</span></p>
         <h3>TCP和UDP的区别</h3>
         <p>1.TCP是面向链接的，UDP是无链接的。<br />
            2.TCP仅支持单播传输，UDP提供单播，多播，广播的功能。<br />
            3.TCP的三次握手保证了数据的可靠性，UDP是无链接的，无链接所以数据不需要客户端或服务端确认，根本不知道是否收到数据，所以不可靠。<br />
            4.UDP的头部开销比TCP的更小，数据传输速率更高，实时性更好。
         </p>
         <h3>HTTP请求跨域问题</h3>
         <h4>跨域的原理</h4>
         <p>跨域，是指浏览器不能请求其他网站的脚本，是浏览器的同源策略造成的。<br />
            同源策略，是指协议，端口号，域名不同就是不同源。<br />
            跨域原理，是指通过各种方式避开浏览器的安全机制。</p>
         <h4>解决跨域的一些方法</h4>
         <p>JSONP：创建一个script标签，src设置为接口地址，接口参数，必须要带一个自定义函数名，要不然后台无法返回数据，通过定义的函数名去接受返回值。只支持get请求。<br />
            proxy代理 目前常用方式,通过服务器设置代理。<br />
            form表单请求：表单内容就是请求值，但是提交后是没有响应的。<br />
            window.postMessage() 利用h5新特性window.postMessage()。<br />
            CORS跨域资源共享，服务器设置对CORS的支持原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求
            </p>
    </div>
  )
}

export default JobInterview